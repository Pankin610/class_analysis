//---------------------------------------------------------------------------

#include <vcl.h>
#include <vector>
#include <utility>
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <random>
#include <unordered_map>
#include <ctime>
#include <windows.h>
#include <iomanip>
#include <cmath>

using namespace std;

#pragma hdrstop

#include "Unit1.h"
#include "Unit2.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;

const int N = 55;

int n, friends[N][N], table[N][N], res = 0, best_res = -1000000000, taken_student = -1;
long long friend_mask[N];
string name[N], filename;
bool vis[N], seatable[N][7][4];
vector< vector< pair<int, int> > > seating(7, vector< pair<int, int> >(4, make_pair(-1, -1))), best_seating(7, vector< pair<int, int> >(4, make_pair(-1, -1)));
string limits[N], output;

unordered_map<string, int> id;

//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------

string to_string(String x) {
	return AnsiString(x.c_str()).c_str();
}

bool validLimitation(string s) {
	vector<int> t;
	for (int i = 0; i < s.size(); i++) {
		if (!(s[i] >= '0' && s[i] <= '9'))
			continue;
		int x = 0, j = i;
		for (; j < s.size() && s[j] >= '0' && s[j] <= '9'; j++) {
			x = x * 10;
			x += s[j] - '0';
		}
		i = j;
		t.push_back(x);
	}
	if (t.size() != 4) {
		return false;
	}
	if (t[1] < t[0] || t[3] < t[2]) {
		return false;
	}
	if (t[0] < 1 || t[1] > 6 || t[2] < 1 || t[3] > 3) {
		return false;
	}
	return true;
}

int getStudentId(string s) {
	int x = -1;
	if (id.find(s) != id.end()) {
		x = id[s];
	}
	else {
		x = 0;
		for (int i = 0; i < s.size(); i++) {
			x = x * 10;
			x += s[i] - '0';
			if (!(s[i] >= '0' && s[i] <= '9')) {
				x = -1;
				break;
			}
		}
		if (x < 1 || x > n) {
			x = -1;
		}
	}
	return x;
}

void parse(string &s, vector<int> &t) {
	for (int i = 0; i < s.size(); i++) {
		if (!(s[i] >= '0' && s[i] <= '9'))
			continue;
		int x = 0, j = i;
		for (; j < s.size() && s[j] >= '0' && s[j] <= '9'; j++) {
			x = x * 10;
			x += s[j] - '0';
		}
		i = j;
		t.push_back(x);
	}
}

void dfs(int v, vector<int>& cur) {
	vis[v] = true;
	cur.push_back(v);

	for (int i = 1; i <= n; i++) {
		if (friends[v][i] > 0 && !vis[i])
			dfs(i, cur);
	}
}

void getIndependantGroups() {
	vector<vector<int>> groups;
	fill(vis, vis + N, false);
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			groups.push_back(vector<int>(0));
			dfs(i, groups.back());
		}
	}

	output = output + "Независимых групп: " + to_string(IntToStr((int)groups.size())) + '\n';
	for (int i = 0; i < groups.size(); i++) {
		output += "Группа " + to_string(IntToStr(i + 1)) + ": ";
		for (int j = 0; j < groups[i].size(); j++) {
			output += name[groups[i][j]];
			if (j + 1 < groups[i].size())
				output += ", ";
			if ((j + 1) % 6 == 0) {
				output += '\n';
			}
		}
		output += '\n';
	}
	output += '\n';
}

inline void del(vector<int> &d, int i) {
	swap(d[i], d.back());
	d.pop_back();
}

inline int popcount(long long mask) {
	int res = 0;
	while (mask > 0) {
		res++;
		mask -= mask & -mask;
	}
	return res;
}

void brute(long long mask, int i, long long &res, long long addable) {
	if (addable == 0 || i == n) {
		if (popcount(mask) > popcount(res)) {
			res = mask;
		}
		return;
	}
	if (((addable >> i) & 1) == 1) {
		brute(mask | ((long long)1 << i), i + 1, res, addable & friend_mask[i + 1]);
	}
	brute(mask, i + 1, res, addable & ((((long long)1 << n) - 1) ^ ((long long)1 << i)));
}

void getMaxClique() {
	long long res = 0;
	brute(0, 0, res, ((long long)1 << n) - 1);

	output += "Самая большая кампания друзей (где каждый дружит с каждым): ";
	for (int i = 0; i < n; i++) {
		if (((res >> i) & 1) == 1) {
			output += name[i + 1];
			if (((long long)1 << (i + 1)) <= res)
				output += ", ";
		}
	}
	output += '\n';
}

const int MX = 37 + 18 + 5;

struct edge {
	int v, p, rev;
	edge(int v, int p, int rev) {
		this->v = v;
		this->p = p;
		this->rev = rev;
	}
	edge() {}
};
vector<edge> g[MX];
vector<int> order[MX];
pair<int, int> desk[40];

inline void addEdge(int u, int v, int p) {
	g[u].push_back(edge(v, p, g[v].size()));
	g[v].push_back(edge(u, 0, g[u].size() - 1));
}

bool dfs(int v) {
	if (v == MX - 1)
		return true;
	if (vis[v])
		return false;
	vis[v] = true;
	while (order[v].size() < g[v].size())
		order[v].push_back(order[v].size());
	random_shuffle(order[v].begin(), order[v].end());
	for (int j = 0; j < g[v].size(); j++) {
		int i = order[v][j];
		if (g[v][i].p == 0)
			continue;
		if (dfs(g[v][i].v)) {
			g[v][i].p--;
			g[g[v][i].v][g[v][i].rev].p++;
			return true;
		}
	}
	return false;
}

bool getRandomSeating() {
	seating = vector<vector<pair<int, int>>>(7, vector< pair<int, int> >(4, make_pair(-1, -1)));

	fill(g, g + MX, vector<edge>(0));
	for (int i = 1; i <= 36; i++) {
		addEdge(0, i, 1);
		for (int row = 1; row <= 6; row++) {
			for (int col = 1; col <= 3; col++) {
				if (seatable[i][row][col]) {
					addEdge(i, 37 + (row - 1) * 3 + col - 1, 1);
				}
			}
		}
	}
	for (int row = 1; row <= 6; row++) {
		for (int col = 1; col <= 3; col++) {
			addEdge(37 + (row - 1) * 3 + col - 1, MX - 1, 2);
		}
	}

	int flow = 0;

	fill(vis, vis + MX, false);
	while (dfs(0)) {
		fill(vis, vis + MX, false);
		flow++;
	}

	for (int i = 1; i <= 36; i++) {
		for (int j = 0; j < g[i].size(); j++) {
			if (g[i][j].v >= 37 && g[i][j].p == 0) {
				int row = (g[i][j].v - 37) / 3 + 1, col = (g[i][j].v - 37) % 3 + 1;
				if (seating[row][col].first == -1)
					seating[row][col].first = i;
				else
					seating[row][col].second = i;
				desk[i] = make_pair(row, col);
			}
		}
	}

	res = 0;
	for (int row = 1; row <= 6; row++) {
		for (int col = 1; col <= 3; col++) {
			res += friends[seating[row][col].first][seating[row][col].second];
		}
	}

	return (flow == 36);
}

pair<int, int> to_swap[36 * 36 + 5];
int o;
inline bool Anneale() {
	o = 0;
	for (int i = 1; i <= 36; i++) {
		for (int j = i + 1; j <= 36; j++) {
			if (seatable[i][desk[j].first][desk[j].second] && seatable[j][desk[i].first][desk[i].second]) {
				int delta = 0;
				delta -= friends[seating[desk[j].first][desk[j].second].first][seating[desk[j].first][desk[j].second].second];
				delta -= friends[seating[desk[i].first][desk[i].second].first][seating[desk[i].first][desk[i].second].second];

				if (seating[desk[i].first][desk[i].second].first != i) {
					swap(seating[desk[i].first][desk[i].second].first, seating[desk[i].first][desk[i].second].second);
				}
				if (seating[desk[j].first][desk[j].second].first != j) {
					swap(seating[desk[j].first][desk[j].second].first, seating[desk[j].first][desk[j].second].second);
				}

				swap(seating[desk[j].first][desk[j].second].first, seating[desk[i].first][desk[i].second].first);

				delta += friends[seating[desk[j].first][desk[j].second].first][seating[desk[j].first][desk[j].second].second];
				delta += friends[seating[desk[i].first][desk[i].second].first][seating[desk[i].first][desk[i].second].second];

				swap(seating[desk[j].first][desk[j].second].first, seating[desk[i].first][desk[i].second].first);

				if (delta > 0) {
					to_swap[o] = make_pair(i, j);
					o++;
				}
			}
		}
	}
	if (o == 0) {
		if (res > best_res) {
			best_seating = seating;
			best_res = res;
		}
		return false;
	}

	int x = rand() % o;
	int i = to_swap[x].first, j = to_swap[x].second;

	res -= friends[seating[desk[j].first][desk[j].second].first][seating[desk[j].first][desk[j].second].second];
	res -= friends[seating[desk[i].first][desk[i].second].first][seating[desk[i].first][desk[i].second].second];

	if (seating[desk[i].first][desk[i].second].first != i) {
		swap(seating[desk[i].first][desk[i].second].first, seating[desk[i].first][desk[i].second].second);
	}
	if (seating[desk[j].first][desk[j].second].first != j) {
		swap(seating[desk[j].first][desk[j].second].first, seating[desk[j].first][desk[j].second].second);
	}

	swap(seating[desk[j].first][desk[j].second].first, seating[desk[i].first][desk[i].second].first);
	swap(desk[i], desk[j]);

	res += friends[seating[desk[j].first][desk[j].second].first][seating[desk[j].first][desk[j].second].second];
	res += friends[seating[desk[i].first][desk[i].second].first][seating[desk[i].first][desk[i].second].second];

	return true;
}

void getSeating() {
	best_res = -1000000000;
	fill(vis, vis + N, false);
	fill(order, order + MX, vector<int>(0));

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			friends[i][j] = -friends[i][j];
		}
	}
	for (int st = 1; st <= n; st++) {
		vector<int> t;
		parse(limits[st], t);
		for (int x = 1; x <= 6; x++) {
			for (int y = 1; y <= 3; y++) {
				seatable[st][x][y] = (x >= t[0] && x <= t[1] && y >= t[2] && y <= t[3]);
			}
		}
	}
	while (n < 36) {
		n++;
		name[n] = "Пустое место";
		for (int row = 1; row <= 6; row++) {
			for (int col = 1; col <= 3; col++) {
				seatable[n][row][col] = true;
			}
		}
	}

	if (!getRandomSeating()) {
		while (name[n] == "Пустое место")
			n--;
        for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				friends[i][j] = -friends[i][j];
			}
		}
		Form1->Label19->Caption = "Рассадки, удовлетворяющей вашим требованиям, не существует.";
		return;
	}

	clock_t tim = clock();
	while ((double)(clock() - tim) / (double)CLOCKS_PER_SEC < 2.5) {
		while(Anneale());
		getRandomSeating();
	}

	//cout << fixed << setprecision(3) << (double)(clock() - tim) / (double)CLOCKS_PER_SEC << endl;

	seating = best_seating;
	Form1->Label19->Caption = "Коэфициент дружбы в рассадке: " + IntToStr(-best_res);

	//----------------------------------------------------------------------------------------------

	Form1->Edit10->Text = name[seating[1][1].first].c_str();
	Form1->Edit11->Text = name[seating[1][1].second].c_str();
	Form1->Edit12->Text = name[seating[1][2].first].c_str();
	Form1->Edit13->Text = name[seating[1][2].second].c_str();
	Form1->Edit14->Text = name[seating[1][3].first].c_str();
	Form1->Edit15->Text = name[seating[1][3].second].c_str();

	Form1->Edit16->Text = name[seating[2][1].first].c_str();
	Form1->Edit17->Text = name[seating[2][1].second].c_str();
	Form1->Edit18->Text = name[seating[2][2].first].c_str();
	Form1->Edit19->Text = name[seating[2][2].second].c_str();
	Form1->Edit20->Text = name[seating[2][3].first].c_str();
	Form1->Edit21->Text = name[seating[2][3].second].c_str();

	Form1->Edit22->Text = name[seating[3][1].first].c_str();
	Form1->Edit23->Text = name[seating[3][1].second].c_str();
	Form1->Edit24->Text = name[seating[3][2].first].c_str();
	Form1->Edit25->Text = name[seating[3][2].second].c_str();
	Form1->Edit26->Text = name[seating[3][3].first].c_str();
	Form1->Edit27->Text = name[seating[3][3].second].c_str();

	Form1->Edit28->Text = name[seating[4][1].first].c_str();
	Form1->Edit29->Text = name[seating[4][1].second].c_str();
	Form1->Edit30->Text = name[seating[4][2].first].c_str();
	Form1->Edit31->Text = name[seating[4][2].second].c_str();
	Form1->Edit32->Text = name[seating[4][3].first].c_str();
	Form1->Edit33->Text = name[seating[4][3].second].c_str();

	Form1->Edit34->Text = name[seating[5][1].first].c_str();
	Form1->Edit35->Text = name[seating[5][1].second].c_str();
	Form1->Edit36->Text = name[seating[5][2].first].c_str();
	Form1->Edit37->Text = name[seating[5][2].second].c_str();
	Form1->Edit38->Text = name[seating[5][3].first].c_str();
	Form1->Edit39->Text = name[seating[5][3].second].c_str();

	Form1->Edit40->Text = name[seating[6][1].first].c_str();
	Form1->Edit41->Text = name[seating[6][1].second].c_str();
	Form1->Edit42->Text = name[seating[6][2].first].c_str();
	Form1->Edit43->Text = name[seating[6][2].second].c_str();
	Form1->Edit44->Text = name[seating[6][3].first].c_str();
	Form1->Edit45->Text = name[seating[6][3].second].c_str();

	//----------------------------------------------------------------------------------------------

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			friends[i][j] = -friends[i][j];
		}
	}
	while (name[n] == "Пустое место")
		n--;
}

inline void readData() {
	ifstream cin("data.txt");

	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> name[i];
		id[name[i]] = i;
		Form1->StringGrid1->Cells[0][i] = name[i].c_str();
		Form1->StringGrid1->Cells[i][0] = IntToStr(i);
	}

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> friends[i][j];
			table[i][j] = friends[i][j];
			Form1->StringGrid1->Cells[j][i] = IntToStr(table[i][j]);
		}
	}
	Form1->StringGrid1->ColWidths[0] = 105;


	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			friends[i][j] = friends[j][i] = min(friends[i][j], friends[j][i]);
			if (friends[i][j] > 0) {
				friend_mask[i] |= ((long long)1 << (j - 1));
				friend_mask[j] |= ((long long)1 << (i - 1));
			}
		}
	}

	getline(cin, limits[0]);
	for (int i = 1; i <= n; i++) {
		getline(cin, limits[i]);
		//string res = name[i] + " | " + limits[i];
		//Form1->ListBox1->Items->Add(res.c_str());
	}

	/*for (int i = 1; i <= n; i++) {
		for (int row = 1; row <= 6; row++) {
			for (int col = 1; col <= 3; col++) {
				cin >> seatable[i][row][col];
			}
		}
	}  */
}

void UpdateData() {
	ofstream cout("data.txt");

	cout << n << endl;
	for (int i = 1; i <= n; i++) {
		cout << name[i] << endl;
	}
    for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cout << table[i][j] << " ";
		}
		cout << endl;
	}
	for (int i = 1; i <= n; i++) {
        cout << limits[i] << endl;
	}
	Form1->ListBox1->Items->Clear();
	Form1->ListBox2->Items->Clear();
	for (int i = 0; i <= 36; i++) {
		for (int j = 0; j <= 36; j++) {
			Form1->StringGrid1->Cells[j][i] = "";
		}
	}
	fill(friend_mask, friend_mask + N, 0);
	id.clear();
	readData();
}

void __fastcall TForm1::FormCreate(TObject *Sender)
{
	  readData();
}
//---------------------------------------------------------------------------

void __fastcall TForm1::Button1Click(TObject *Sender)
{
	if (taken_student == -1) {
		ShowMessage("Сначала выберите ученика в таблице слева.");
		return;
	}

	name[taken_student] = to_string(Edit5->Text);

	string Lim = "";

	string val = to_string(Edit1->Text);
	if (val.size() > 1) {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	if (!(val[0] >= '1' && val[0] <= '6')) {
        ShowMessage("Неправильный формат ввода.");
		return;
	}
	Lim = Lim + val[0] + " ";

	val = to_string(Edit2->Text);
	if (val.size() > 1) {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	if (!(val[0] >= '1' && val[0] <= '6')) {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	Lim = Lim + val[0] + " ";

	val = to_string(Edit3->Text);
	if (val.size() > 1) {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	if (!(val[0] >= '1' && val[0] <= '3')) {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	Lim = Lim + val[0] + " ";

	val = to_string(Edit4->Text);
	if (val.size() > 1) {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	if (!(val[0] >= '0' && val[0] <= '3')) {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	Lim = Lim + val[0];

	if (Lim[0] > Lim[2] || Lim[4] > Lim[6]) {
        ShowMessage("Неправильный формат ввода.");
		return;
	}
	limits[taken_student] = Lim;

    UpdateData();
}
//---------------------------------------------------------------------------

void __fastcall TForm1::Button2Click(TObject *Sender)
{
	if (Edit4->Text == "" || Edit5->Text == "" || Edit6->Text == "") {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	if (StrToInt(Edit6->Text) < 0 || StrToInt(Edit6->Text) > 10) {
		ShowMessage("Неправильный формат ввода.");
		return;
	}

	string name1, name2;

	name1 = AnsiString(Edit4->Text.c_str()).c_str();
	name2 = AnsiString(Edit5->Text.c_str()).c_str();

	int x = 0, y = 0;
	if (id.find(name1) != id.end()) {
		x = id[name1];
	}
	else {
		for (int i = 0; i < name1.size(); i++) {
			x = x * 10;
			x += name1[i] - '0';
			if (!(name1[i] >= '0' && name1[i] <= '9')) {
				ShowMessage("Неправильный формат ввода.");
				return;
			}
		}
	}

	if (id.find(name2) != id.end()) {
		y = id[name2];
	}
	else {
		for (int i = 0; i < name2.size(); i++) {
			y = y * 10;
			y += name2[i] - '0';
			if (!(name2[i] >= '0' && name2[i] <= '9')) {
				ShowMessage("Неправильный формат ввода.");
				return;
			}
		}
	}

	table[x][y] = table[y][x] = StrToInt(Edit6->Text);
	UpdateData();
}
//---------------------------------------------------------------------------


void __fastcall TForm1::Button6Click(TObject *Sender)
{
	int ind = ListBox1->ItemIndex;
	if (ind == -1) {
		return;
	}

	ind++;
	for (int i = ind; i != n; i++) {
		limits[i] = limits[i + 1];
		name[i] = name[i + 1];
		for (int j = 1; j <= n; j++) {
			table[i][j] = table[i + 1][j];
		}
	}
	for (int nm = 1; nm < n; nm++) {
		for (int j = ind; j != n; j++) {
			table[nm][j] = table[nm][j + 1];
		}
	}
	n--;

	UpdateData();
}
//---------------------------------------------------------------------------

void __fastcall TForm1::Button5Click(TObject *Sender)
{
	output = "";
	Form1->Label20->Caption = "Подождите несколько секунд...";
	getIndependantGroups();
	getMaxClique();
	getSeating();
	Form1->Label20->Caption = "";
	Label21->Caption = output.c_str();
}
//---------------------------------------------------------------------------

void __fastcall TForm1::StringGrid1SelectCell(TObject *Sender, int ACol, int ARow,
		  bool &CanSelect)
{
	if (ACol != 0 || ARow > n) {
		return;
	}

	ListBox1->Items->Clear();
	ListBox2->Items->Clear();

	string temp = to_string(StringGrid1->Cells[ACol][ARow]);
	int num = id[temp];

    taken_student = num;

	vector<int> restrictions;
	parse(limits[num], restrictions);

	Edit1->Text = IntToStr(restrictions[0]);
	Edit2->Text = IntToStr(restrictions[1]);
	Edit3->Text = IntToStr(restrictions[2]);
	Edit4->Text = IntToStr(restrictions[3]);

	Edit5->Text = name[num].c_str();

	for (int i = 1; i <= n; i++) {
		if (friends[num][i] > 0) {
			ListBox1->Items->Add(name[i].c_str());
		}
		if (friends[num][i] < 0) {
			ListBox2->Items->Add(name[i].c_str());
		}
	}
}
//---------------------------------------------------------------------------


void __fastcall TForm1::Image1Click(TObject *Sender)
{
	if (taken_student == -1) {
		ShowMessage("Сначала выберите ученика в таблице слева.");
		return;
	}
	Form2->ShowModal();
}
//---------------------------------------------------------------------------




void __fastcall TForm1::Button3Click(TObject *Sender)
{
	if (Edit6->Text == "") {
		ShowMessage("Неправильный формат ввода.");
		return;
	}
	if (n == 36) {
		ShowMessage("Превышен лимит учеников");
		return;
	}

	string Lim  = "1 6 1 3";
	string Name = to_string(Edit6->Text);

	if (!validLimitation(Lim)) {
		ShowMessage("Неправильный формат ограничения по зрению");
		return;
	}

	n++;
	name[n] = Name;
	limits[n] = Lim;
	UpdateData();
}

//---------------------------------------------------------------------------

void __fastcall TForm1::Image3Click(TObject *Sender)
{
    if (taken_student == -1) {
		ShowMessage("Сначала выберите ученика в таблице слева.");
		return;
	}
	Form2->ShowModal();
}
//---------------------------------------------------------------------------

